package nextflow.dag

import nextflow.Session
import nextflow.processor.TaskId
import nextflow.trace.TraceRecord
import groovy.util.logging.Slf4j

import javax.xml.stream.XMLOutputFactory
import javax.xml.stream.XMLStreamWriter
import java.nio.charset.Charset
import java.nio.file.Files
import java.nio.file.Paths
import java.text.SimpleDateFormat
import java.nio.file.Path

@Slf4j

/**
 * Render the DAG in .dax Format representing the Workflow.
 * Renders the minimal DAG in .dax Format for simulations in Wrench (https://wrench-project.org/)
 * @author Frederic Risling
 */
class DAXRenderer implements DagRenderer {

    /**
     * The current DAG
     */
    private DAG dag

    /**
     * All the trace records of the current execution.
     * Contains the runtime for the tasks
     */
    private Map<TaskId, TraceRecord> records

    /**
     * The path where the DAG will be saved
     */
    private Path path

    /**
     * the name of the executed workflow
     */
    private String namespace

    /**
     * the current session for this workflow
     */
    private Session session

    /**
     * the list of input and output files of all executed tasks
     */
    private List<FileDependency> files

    /**
     * helper Map to avoid duplicate output file-names in the .dax file
     */
    private Map<String, Integer> duplicates


    /**
     * Finals for creating the header information in the .dax file
     */
    private static final String XMLNS = "http://pegasus.isi.edu/schema/DAX"
    private static final String XMLNS_XSI = "http://www.w3.org/2001/XMLSchema-instance"
    private static final String XSI_LOCATION = XMLNS + " http://pegasus.isi.edu/schema/dax-2.1.xsd"
    private static final String VERSION = "2.1"

    /**
     * Constructor of a DAXRenderer
     * @param records
     * @param session
     */
    DAXRenderer(Map<TaskId, TraceRecord> records, Session session) {
        this.records = records
        this.session = session
        this.namespace = generateNamespace()
        this.files = new ArrayList<FileDependency>()
        this.duplicates = new HashMap<String, Integer>()
    }

    /**
     * Overrides the renderDocument() method of the DagRenderer Interface
     * @param dag
     * @param file
     */
    void renderDocument(DAG dag, Path file) {
        this.dag = dag
        this.path = file
        renderDAX()
    }

    /**
     * creates a <filename>.dax representation in the current directory
     */
    void renderDAX() {
        //Create .dax file Header and meta information
        final Charset charset = Charset.defaultCharset()
        Writer bw = Files.newBufferedWriter(this.path, charset)
        final XMLOutputFactory xof = XMLOutputFactory.newFactory()
        final XMLStreamWriter w = xof.createXMLStreamWriter(bw)
        w.writeStartDocument(charset.displayName(), "1.0")
        w.writeComment(" generated: " + new SimpleDateFormat("yyyy-MM-dd_HH:mm:ss").format(Calendar.getInstance().getTime()))
        w.writeComment(" generated by: " + System.getProperty("user.name") + " ")
        w.writeStartElement("adag")
        w.writeAttribute("xmlns", XMLNS)
        w.writeAttribute("xmlns:xsi", XMLNS_XSI)
        w.writeAttribute("xsi:schemaLocation", XSI_LOCATION)
        w.writeAttribute("version", VERSION)
        //TODO: Attribut count
        //TODO: Attribut index
        //TODO: Attribut name
        //TODO: Attribut jobCount
        //TODO: Attribut fileCount
        //TODO: Attribut childCount

        //Part 1: List of all referenced files
        def edges = dag.edges
        w.writeComment(" part 1: list of all referenced files (may be empty) ")
        def refFiles = edges.stream()
                .filter(edge -> edge.from != null)
                .filter(edge -> edge.from.type == DAG.Type.ORIGIN)
                .map(edge -> edge.from.label.toString())
                .toArray()
        for (file in refFiles) {
            if (file.toString() == "null") {
                break
            }
            w.writeStartElement("file")
            w.writeAttribute("name", file.toString())
            w.writeEndElement()
        }

        //Part 2: List of all executed Jobs
        w.writeComment(" part 2: definition of all jobs (at least one) ")
        for (record in records) {
            //add files to file list
            addFilesForRecord(record.value)
            //<job>-element + attributes
            w.writeStartElement("job")
            String id = record.value.get("task_id").toString()
            w.writeAttribute("id", id)
            w.writeAttribute("namespace", namespace)
            String name = record.value.get("name")
            w.writeAttribute("name", name)
            double realtime = record.value.get("realtime") / 1000
            w.writeAttribute("runtime", Double.toString(realtime))
            w.writeAttribute("numcores", record.value.get("cpus").toString())
            //input files
            writeInputEdges(record.value, w)
            //output files
            writeOutputEdges(record.value, w)
            //close </job>
            w.writeEndElement()
        }
        //Dependencies
        w.writeComment(" part 3: list of control-flow dependencies (may be empty) ")
        writeDependencies(w)
        w.writeEndElement()
        w.writeEndDocument()
        w.flush()
        bw.flush()
        bw.close()
    }

    String generateNamespace() {
        String name = session.getWorkflowMetadata().projectName
        def split = name.split("/")
        return split[1]
    }

    void addFilesForRecord(TraceRecord record) {
        //the directory for this record
        Path path = Paths.get(record.get("workdir"))
        //the list of input files
        List<FileDependency> inputFiles = new ArrayList<>()

        def commandFile = Files.walk(path)
                .map(file -> file.toFile())
                .filter(file -> file.name == ".command.run")
                .findFirst()
                .get()
        //parse input files
        try {
            FileInputStream fstream = new FileInputStream(commandFile)
            BufferedReader br = new BufferedReader(new InputStreamReader(fstream))
            def lines = br.readLines()
            List<String> inputsString = new ArrayList<String>()
            def outputsString
            for (int i = 0; i < lines.size(); i++) {
                if (lines.get(i).contains("# stage input files")) {
                    int count = 1
                    while (!lines.get(i + count).contains("}")) {
                        inputsString.add(lines.get(i + count))
                        count++
                    }
                }
            }
            String[] inputFilesString = inputsString.stream()
                    .filter(s -> s.contains("/"))
                    .map(s -> s.split(" "))
                    .map(s -> s[s.size() - 2] + " " + s[s.size() - 1])
                    .toArray()

            for (f in inputFilesString) {
                String fileName = f.toString().split(" ").last()
                Path pathTo = Paths.get(f.toString().split(" ").first())
                String toId = record.get("task_id")
                //file size
                long fileSize = Files.size(pathTo)
                FileDependency addInput = new FileDependency(fileName, pathTo, toId, fileSize, false)
                files.add(addInput)
                inputFiles.add(addInput)
            }

            fstream.close()
        } catch (Exception e) {
            log.error("Error: " + e.getMessage())
        }
        //String list of input files
        String[] inputsString = files.stream()
        //.filter(file -> file.toIds.contains(record.get("task_id").toString()))
                .filter(file -> file.fromId == null)
                .map(file -> file.name)
                .toArray()

        //parse output file
        File[] outputFiles = Files.walk(path)
                .map(file -> file.toFile())
                .filter(file -> !file.name.startsWith("."))
                .filter(file -> file.name.contains("."))
                .filter(file -> !file.name.contains("log"))
                .filter(file -> !file.name.contains("err"))
                .filter(file -> !file.name.contains("info"))
                .filter(file -> !inputsString.contains(file.name))
                .toArray()
        for( file in outputFiles){
            //check whether file already exists
            if(inputsString.contains(file.name)){
                files.stream().filter(f -> f.name == file.name)
                        .each {it -> it.addDirectoryFrom(file.toPath(), record.get("task_id").toString())}
            }
            //file doesn't exist
            else{
                FileDependency output = new FileDependency(file.name, file.toPath(), record.get("task_id").toString(), file.size(), true)
                files.add(output)
            }
        }
    }

    void writeInputEdges(TraceRecord record, XMLStreamWriter w) {
        FileDependency[] inputs = files.stream()
                    .filter(file -> file.toIds.contains(record.get("task_id").toString()))
                    .toArray()
        for (i in inputs){
            w.writeStartElement("uses")
            w.writeAttribute("file", i.name)
            w.writeAttribute("link", "input")
            w.writeAttribute("size", i.fileSize.toString())
            w.writeEndElement()
        }
    }

    void writeOutputEdges(TraceRecord record, XMLStreamWriter w) {
        FileDependency[] outputs = files.stream()
                .filter(file -> file.fromId==record.get("task_id").toString())
                .toArray()
        for (o in outputs){
            w.writeStartElement("uses")
            w.writeAttribute("file", normalizeOutputFileName(o.name))
            w.writeAttribute("actual_file", o.name)
            w.writeAttribute("link", "output")
            w.writeAttribute("size", o.fileSize.toString())
            w.writeEndElement()
        }

    }

    String normalizeOutputFileName(String filename){
        int count = files.stream().filter(file -> file.fromId != null)
                .filter(file -> file.name == filename.toString()).count()

        ArrayList<FileDependency> outputs= files.stream().filter(file -> file.fromId != null)
                .filter(file -> file.name == filename).toArray()
        if(count > 1){
            //log.info("!!!!!!  duplicates.get($filename): "+ duplicates.get(filename).toString())
            if(duplicates.get(filename) == null) {
                duplicates.put(filename, 1)
                //log.warn(duplicates.get(filename) + " files with this name: " + filename)
            }
            else{
                int current_number = duplicates.get(filename)
                duplicates.replace(filename, current_number+1)
                //log.info(duplicates.get(filename.toString()) + " files with this name: " + filename)
            }
        }
        //log.info(duplicates.toString())

        return filename
    }

    void writeDependencies(XMLStreamWriter w) {
        List<FileDependency> dependencies = connectInputsAndOutputs()
                                            .stream()
                                            .filter(dep -> dep.toIds.size()>0)
                                            .filter(dep->dep.fromId!=null)
                                            .toArray()

        for (record in records){
            def id = record.value.get("task_id")
            FileDependency[] dependenciesForRecord = dependencies.stream()
                                            .filter(dep -> dep.toIds.contains(id.toString()))
                                            .toArray()
            List<String> alreadyWritten = new ArrayList()
            if(dependenciesForRecord.size()<1) continue
            w.writeStartElement("child")
            w.writeAttribute("ref", id.toString())
            for (dep in dependenciesForRecord){
                if(alreadyWritten.contains(dep.fromId)){
                    continue
                }
                else{
                    w.writeStartElement("parent")
                    w.writeAttribute("ref", dep.fromId)
                    w.writeEndElement()
                    alreadyWritten.add(dep.fromId.toString())
                }
            }
            w.writeEndElement()
        }
    }

    List<FileDependency> connectInputsAndOutputs(){
        ArrayList<FileDependency> inputs = files.stream()
                                        .filter(file -> file.toIds.size()>0)
                                        .toArray()

        ArrayList<FileDependency> outputs = files.stream()
                                        .filter(file -> file.fromId!=null)
                                        .toArray()

        ArrayList<FileDependency> ret = new ArrayList<>()
        for (output in outputs){
            ArrayList<FileDependency> dependentOn = inputs.stream()
                                    .filter(input -> input.name == output.name)
                                    .toArray()
            for (dep in dependentOn){
                FileDependency f = new FileDependency(output.name, output.directoryFrom, output.fromId, output.fileSize, true)
                f.toIds.add(dep.toIds.first())
                f.directoriesTo.add(dep.directoriesTo.first())
                ret.add(f)
            }

        }
        return ret
    }


    class FileDependency {
        String name
        Path directoryFrom
        List<Path> directoriesTo = new ArrayList<>()
        String fromId
        List<String> toIds = new ArrayList<>()
        Long fileSize

        FileDependency(String name, Path directory, String id, Long fileSize, boolean output) {
            if (output) {
                this.name = name
                this.directoryFrom = directory
                this.fromId = id
                this.fileSize = fileSize
            } else {
                this.name = name
                this.directoriesTo.add(directory)
                this.toIds.add(id)
                this.fileSize = fileSize
            }
        }

        void addDirectoriesTo(Path to, String toId) {
            directoriesTo.add(to)
            toIds.add(toId)
        }

        void addDirectoryFrom(Path from, String fromId) {
            if (directoryFrom != null || this.fromId != null) {
                log.error("input directory already exist for this file")
            } else {
                this.directoryFrom = from
                this.fromId = fromId
            }
        }

        boolean hasInputs(FileDependency entry) {
            if (entry.fromId == null || entry.directoryFrom == null) {
                return false
            } else return true
        }

        boolean hasOutputs(FileDependency entry) {
            if (entry.toIds.size() == 0 || entry.directoriesTo.size() == 0) return false
            else return true
        }

        String toString(){
            return "name: " + this.name + " fromId: " + this.fromId + " directoryFrom: " + this.directoryFrom.toString() \
                    + " toIds: " + this.toIds.toString() + " directoriesTo: " + this.directoriesTo.toString()
        }
    }

}